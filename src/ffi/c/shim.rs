use std::{alloc::AllocError, any::Any, fmt::Debug, marker::PhantomData, mem::MaybeUninit, panic::{Location, RefUnwindSafe, UnwindSafe}};

use thiserror::Error;

use crate::AddFamilyError;

use super::FFIConvertError;

#[repr(transparent)]
pub(super) struct DefaultNaN<T>(T);

impl Default for DefaultNaN<f32> {
    fn default() -> Self {
        Self(f32::NAN)
    }
}
impl Default for DefaultNaN<f64> {
    fn default() -> Self {
        Self(f64::NAN)
    }
}

#[repr(C)]
#[derive(Default)]
pub struct IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}

/// Error generated by FFI
#[derive(Debug, Clone, Error)]
#[non_exhaustive]
pub enum CFFIError {
    /// Allocation failed
    #[error("Allocation failed")]
    Alloc(AllocError),
    /// Required argument was null
    #[error("Required argument {0} was null")]
    NullArgument(&'static str),
    #[error(transparent)]
    AddFamily(#[from] AddFamilyError),
    /// Type conversion failure
    #[error("Type conversion failure")]
    BadConversion(#[source] FFIConvertError),
    /// Required argument conversion failure
    #[error("Required argument {param_name} conversion failed")]
    BadInput {
        param_name: &'static str,
        #[source]
        inner: FFIConvertError,
    },
    /// Message extracted from catching a `panic`
    #[error("Panic in FFI method: {0}")]
    PanicStr(String),
}

impl CFFIError {
    /// Get errno for error
    fn errno(&self) -> i32 {
        match self {
            Self::Alloc(..) => libc::ENOMEM,
            Self::NullArgument(..) => libc::EINVAL,
            Self::BadConversion(..) => libc::EINVAL,
            Self::BadInput {..} => libc::EINVAL,
            Self::PanicStr(..) => libc::EFAULT,
            Self::AddFamily(..) => libc::EFBIG,
        }
    }
}

impl From<FFIConvertError> for CFFIError {
    fn from(value: FFIConvertError) -> Self {
        Self::BadConversion(value)
    }
}

pub(super) mod param {
    use crate::ffi::c::FFIConvertError;

    use super::CFFIError;

    /// Try to read FFI method parameter.
    /// Makes generating FFI errors easier from [TryFrom] impls.
    pub(in super::super) fn try_read<R, T>(value: T, name: &'static str) -> Result<R, CFFIError> where R: TryFrom<T>, FFIConvertError: From<<R as TryFrom<T>>::Error> {
        match <R as TryFrom<T>>::try_from(value) {
            Ok(res) => Ok(res),
            Err(e) => {
                let inner = <FFIConvertError as From<_>>::from(e);
                Err(CFFIError::BadInput { param_name: name, inner })
            }
        }
    }
}

/// CFFI input pointer.
#[repr(transparent)]
pub struct InPtr<'a, T>{
    ptr: *const T,
    lifetime: PhantomData<&'a T>,
}

/// CFFI output pointer
#[repr(transparent)]
pub struct OutPtr<'a, T> {
    ptr: *mut T,
    lifetime: PhantomData<&'a mut T>,
}

/// CFFI input & output pointer
pub struct InOutPtr<'a, T> {
    ptr: *mut T,
    lifetime: PhantomData<&'a mut T>,
}

impl<'a, T> RefUnwindSafe for InPtr<'a, T> {}
impl<'a, T> UnwindSafe for InPtr<'a, T> {}
impl<'a, T> RefUnwindSafe for OutPtr<'a, T> {}

fn dispatch_err(name: &'static str, err: impl Any + Debug) -> CFFIError {
    #[cold]
    fn dispatch_any(param_name: &'static str, err_any: &dyn Any) -> Option<CFFIError> {
        if let Some(fce) = err_any.downcast_ref::<FFIConvertError>() {
            return Some(CFFIError::BadInput { param_name, inner: fce.clone() });
        }
        if let Some(cfe) = err_any.downcast_ref::<CFFIError>() {
            return match cfe {
                CFFIError::BadConversion(fce) => Some(CFFIError::BadInput { param_name, inner: fce.clone() }),
                _ => Some(cfe.clone()),
            }
        }
        None
    }
    
    // Limit codegen
    if let Some(err) = dispatch_any(name, &err) {
        return err;
    }

    let msg = format!("{err:?}");
    CFFIError::BadInput { param_name: name, inner: FFIConvertError::Other(msg) }
}

/// FFI pointer that may be read from
pub(super) trait ReadPtr<'a, T> {
    /// Get as raw pointer
    fn ptr(&self) -> *const T;

    fn ptr_nonnull(&self, param_name: &'static str) -> Result<*const T, CFFIError> {
        let ptr = self.ptr();
        if ptr.is_null() {
            Err(CFFIError::NullArgument(param_name))
        } else {
            Ok(ptr)
        }
    }

    unsafe fn try_read<R>(&self, param_name: &'static str) -> Result<R, CFFIError> where R: TryFrom<*const T>, <R as TryFrom<*const T>>::Error: Debug + Any {
        let ptr = self.ptr_nonnull(param_name)?;
        match <R as TryFrom<*const T>>::try_from(ptr) {
            Ok(v) => Ok(v),
            Err(err) => Err(dispatch_err(param_name, err)),
        }
    }

    /// Try to read as array of length `len`.
    /// 
    /// Returns CFFIError if raw pointer was null
    unsafe fn try_array(&self, len: usize, param_name: &'static str) -> Result<&'a [T], CFFIError> {
        let ptr = self.ptr_nonnull(param_name)?;
        Ok(std::slice::from_raw_parts(ptr, len))
    }

    unsafe fn try_ref(&self, param_name: &'static str) -> Result<&'a T, CFFIError> {
        match self.ptr().as_ref() {
            Some(r) => Ok(r),
            None => Err(CFFIError::NullArgument(param_name)),
        }
    }

    unsafe fn try_mut(&mut self, param_name: &'static str) -> Result<&'a mut T, CFFIError> {
        Ok((self.ptr_nonnull(param_name)? as *mut T).as_mut().unwrap())
    }
}

impl<'a, T> ReadPtr<'a, T> for InPtr<'a, T> {
    fn ptr(&self) -> *const T {
        self.ptr
    }
}

impl<'a, T> ReadPtr<'a, T> for InOutPtr<'a, T> {
    fn ptr(&self) -> *const T {
        self.ptr
    }
}

impl<'a, T> OutPtr<'a, T> {
    pub(super) unsafe fn try_ref(&self, param_name: &'static str) -> Result<&'a mut MaybeUninit<T>, CFFIError> {
        match self.ptr.as_uninit_mut() {
            Some(res) => Ok(res),
            None => Err(CFFIError::NullArgument(param_name)),
        }
    }

    /// Write value to parameter if not null
    pub(super) unsafe fn maybe_write(&self, value: T) {
        if let Some(dst) = self.ptr.as_uninit_mut() {
            dst.write(value);
        }
    }

    /// Try to write value, returning error if null
    #[must_use]
    pub(super) unsafe fn maybe_try_write<V: TryInto<T>>(&self, param_name: &'static str, value: V) -> Result<(), CFFIError> where CFFIError: From<<V as TryInto<T>>::Error> {
        let dst = self.try_ref(param_name)?;
        dst.write(value.try_into()?);
        Ok(())
    }
}

fn cffi_catch<R>(callback: impl (FnOnce() -> Result<R, CFFIError>) + UnwindSafe) -> Result<R, CFFIError> {
    match std::panic::catch_unwind(callback) {
        Ok(result) => result,
        Err(panic_data) => {
            let msg = if let Some(msg) = panic_data.downcast_ref::<String>() {
                msg.clone()
            } else if let Some(msg) = panic_data.downcast_ref::<&str>() {
                String::from(*msg)
            } else {
                format!("{panic_data:?}")
            };
            Err(CFFIError::PanicStr(msg))
        }
    }
}

fn handle_cffi_error(location: &Location, error: CFFIError) {
    use errno::Errno;

    let errno = Errno(error.errno());
    eprintln!("Error in {}: {}", location, errno);
    errno::set_errno(errno);
}

#[track_caller]
pub(super) fn cffi_wrapper<R>(callback: impl (FnOnce() -> Result<R, CFFIError>) + UnwindSafe) -> R where R: Default {
    match cffi_catch(callback) {
        Ok(result) => result,
        Err(error) => {
            // Constrain codegen
            handle_cffi_error(std::panic::Location::caller(), error);
            R::default()
        }
    }
}